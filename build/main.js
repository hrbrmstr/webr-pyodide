/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const t = window,i$1 = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype,s = Symbol(),e = new WeakMap();class o {constructor(t, i, e) {if (this._$cssResult$ = !0, e !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");this.cssText = t, this.t = i;}get styleSheet() {let t = this.i;const s = this.t;if (i$1 && void 0 === t) {const i = void 0 !== s && 1 === s.length;i && (t = e.get(s)), void 0 === t && ((this.i = t = new CSSStyleSheet()).replaceSync(this.cssText), i && e.set(s, t));}return t;}toString() {return this.cssText;}}const n = (t) => new o("string" == typeof t ? t : t + "", void 0, s),r = (t, ...i) => {const e = 1 === t.length ? t[0] : i.reduce((i, s, e) => i + ((t) => {if (!0 === t._$cssResult$) return t.cssText;if ("number" == typeof t) return t;throw Error("Value passed to 'css' function must be a 'css' function result: " + t + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");})(s) + t[e + 1], t[0]);return new o(e, t, s);},h$1 = (s, e) => {i$1 ? s.adoptedStyleSheets = e.map((t) => t instanceof CSSStyleSheet ? t : t.styleSheet) : e.forEach((i) => {const e = document.createElement("style"),o = t.litNonce;void 0 !== o && e.setAttribute("nonce", o), e.textContent = i.cssText, s.appendChild(e);});},l = i$1 ? (t) => t : (t) => t instanceof CSSStyleSheet ? ((t) => {let i = "";for (const s of t.cssRules) i += s.cssText;return n(i);})(t) : t
  /**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   */;var a$1;const u$1 = window,c$1 = u$1.trustedTypes,d$1 = c$1 ? c$1.emptyScript : "",v$1 = u$1.reactiveElementPolyfillSupport,p = { toAttribute(t, i) {switch (i) {case Boolean:t = t ? d$1 : null;break;case Object:case Array:t = null == t ? t : JSON.stringify(t);}return t;}, fromAttribute(t, i) {let s = t;switch (i) {case Boolean:s = null !== t;break;case Number:s = null === t ? null : Number(t);break;case Object:case Array:try {s = JSON.parse(t);} catch (t) {s = null;}}return s;} },f$1 = (t, i) => i !== t && (i == i || t == t),m$1 = { attribute: !0, type: String, converter: p, reflect: !1, hasChanged: f$1 };class y extends HTMLElement {constructor() {super(), this.o = new Map(), this.isUpdatePending = !1, this.hasUpdated = !1, this.l = null, this.u();}static addInitializer(t) {var i;this.finalize(), (null !== (i = this.v) && void 0 !== i ? i : this.v = []).push(t);}static get observedAttributes() {this.finalize();const t = [];return this.elementProperties.forEach((i, s) => {const e = this.p(s, i);void 0 !== e && (this.m.set(e, s), t.push(e));}), t;}static createProperty(t, i = m$1) {if (i.state && (i.attribute = !1), this.finalize(), this.elementProperties.set(t, i), !i.noAccessor && !this.prototype.hasOwnProperty(t)) {const s = "symbol" == typeof t ? Symbol() : "__" + t,e = this.getPropertyDescriptor(t, s, i);void 0 !== e && Object.defineProperty(this.prototype, t, e);}}static getPropertyDescriptor(t, i, s) {return { get() {return this[i];}, set(e) {const o = this[t];this[i] = e, this.requestUpdate(t, o, s);}, configurable: !0, enumerable: !0 };}static getPropertyOptions(t) {return this.elementProperties.get(t) || m$1;}static finalize() {if (this.hasOwnProperty("finalized")) return !1;this.finalized = !0;const t = Object.getPrototypeOf(this);if (t.finalize(), void 0 !== t.v && (this.v = [...t.v]), this.elementProperties = new Map(t.elementProperties), this.m = new Map(), this.hasOwnProperty("properties")) {const t = this.properties,i = [...Object.getOwnPropertyNames(t), ...Object.getOwnPropertySymbols(t)];for (const s of i) this.createProperty(s, t[s]);}return this.elementStyles = this.finalizeStyles(this.styles), !0;}static finalizeStyles(t) {const i = [];if (Array.isArray(t)) {const s = new Set(t.flat(1 / 0).reverse());for (const t of s) i.unshift(l(t));} else void 0 !== t && i.push(l(t));return i;}static p(t, i) {const s = i.attribute;return !1 === s ? void 0 : "string" == typeof s ? s : "string" == typeof t ? t.toLowerCase() : void 0;}u() {var t;this._ = new Promise((t) => this.enableUpdating = t), this._$AL = new Map(), this.g(), this.requestUpdate(), null === (t = this.constructor.v) || void 0 === t || t.forEach((t) => t(this));}addController(t) {var i, s;(null !== (i = this.S) && void 0 !== i ? i : this.S = []).push(t), void 0 !== this.renderRoot && this.isConnected && (null === (s = t.hostConnected) || void 0 === s || s.call(t));}removeController(t) {var i;null === (i = this.S) || void 0 === i || i.splice(this.S.indexOf(t) >>> 0, 1);}g() {this.constructor.elementProperties.forEach((t, i) => {this.hasOwnProperty(i) && (this.o.set(i, this[i]), delete this[i]);});}createRenderRoot() {var t;const i = null !== (t = this.shadowRoot) && void 0 !== t ? t : this.attachShadow(this.constructor.shadowRootOptions);return h$1(i, this.constructor.elementStyles), i;}connectedCallback() {var t;void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(!0), null === (t = this.S) || void 0 === t || t.forEach((t) => {var i;return null === (i = t.hostConnected) || void 0 === i ? void 0 : i.call(t);});}enableUpdating(t) {}disconnectedCallback() {var t;null === (t = this.S) || void 0 === t || t.forEach((t) => {var i;return null === (i = t.hostDisconnected) || void 0 === i ? void 0 : i.call(t);});}attributeChangedCallback(t, i, s) {this._$AK(t, s);}$(t, i, s = m$1) {var e;const o = this.constructor.p(t, s);if (void 0 !== o && !0 === s.reflect) {const n = (void 0 !== (null === (e = s.converter) || void 0 === e ? void 0 : e.toAttribute) ? s.converter : p).toAttribute(i, s.type);this.l = t, null == n ? this.removeAttribute(o) : this.setAttribute(o, n), this.l = null;}}_$AK(t, i) {var s;const e = this.constructor,o = e.m.get(t);if (void 0 !== o && this.l !== o) {const t = e.getPropertyOptions(o),n = "function" == typeof t.converter ? { fromAttribute: t.converter } : void 0 !== (null === (s = t.converter) || void 0 === s ? void 0 : s.fromAttribute) ? t.converter : p;this.l = o, this[o] = n.fromAttribute(i, t.type), this.l = null;}}requestUpdate(t, i, s) {let e = !0;void 0 !== t && (((s = s || this.constructor.getPropertyOptions(t)).hasChanged || f$1)(this[t], i) ? (this._$AL.has(t) || this._$AL.set(t, i), !0 === s.reflect && this.l !== t && (void 0 === this.C && (this.C = new Map()), this.C.set(t, s))) : e = !1), !this.isUpdatePending && e && (this._ = this.T());}async T() {this.isUpdatePending = !0;try {await this._;} catch (t) {Promise.reject(t);}const t = this.scheduleUpdate();return null != t && (await t), !this.isUpdatePending;}scheduleUpdate() {return this.performUpdate();}performUpdate() {var t;if (!this.isUpdatePending) return;this.hasUpdated, this.o && (this.o.forEach((t, i) => this[i] = t), this.o = void 0);let i = !1;const s = this._$AL;try {i = this.shouldUpdate(s), i ? (this.willUpdate(s), null === (t = this.S) || void 0 === t || t.forEach((t) => {var i;return null === (i = t.hostUpdate) || void 0 === i ? void 0 : i.call(t);}), this.update(s)) : this.P();} catch (t) {throw i = !1, this.P(), t;}i && this._$AE(s);}willUpdate(t) {}_$AE(t) {var i;null === (i = this.S) || void 0 === i || i.forEach((t) => {var i;return null === (i = t.hostUpdated) || void 0 === i ? void 0 : i.call(t);}), this.hasUpdated || (this.hasUpdated = !0, this.firstUpdated(t)), this.updated(t);}P() {this._$AL = new Map(), this.isUpdatePending = !1;}get updateComplete() {return this.getUpdateComplete();}getUpdateComplete() {return this._;}shouldUpdate(t) {return !0;}update(t) {void 0 !== this.C && (this.C.forEach((t, i) => this.$(i, this[i], t)), this.C = void 0), this.P();}updated(t) {}firstUpdated(t) {}}
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
var _$1;y.finalized = !0, y.elementProperties = new Map(), y.elementStyles = [], y.shadowRootOptions = { mode: "open" }, null == v$1 || v$1({ ReactiveElement: y }), (null !== (a$1 = u$1.reactiveElementVersions) && void 0 !== a$1 ? a$1 : u$1.reactiveElementVersions = []).push("1.6.1");const b$1 = window,g$1 = b$1.trustedTypes,w$1 = g$1 ? g$1.createPolicy("lit-html", { createHTML: (t) => t }) : void 0,S$1 = `lit$${(Math.random() + "").slice(9)}$`,$$1 = "?" + S$1,C$1 = `<${$$1}>`,T$1 = document,P$1 = (t = "") => T$1.createComment(t),x = (t) => null === t || "object" != typeof t && "function" != typeof t,A$1 = Array.isArray,k$1 = (t) => A$1(t) || "function" == typeof (null == t ? void 0 : t[Symbol.iterator]),E$1 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g,M$1 = /-->/g,U = />/g,N = RegExp(">|[ \t\n\f\r](?:([^\\s\"'>=/]+)([ \t\n\f\r]*=[ \t\n\f\r]*(?:[^ \t\n\f\r\"'`<>=]|(\"|')|))|$)", "g"),R$1 = /'/g,O$1 = /"/g,V$1 = /^(?:script|style|textarea|title)$/i,j$1 = (t) => (i, ...s) => ({ _$litType$: t, strings: i, values: s }),z = j$1(1),I$1 = Symbol.for("lit-noChange"),H$1 = Symbol.for("lit-nothing"),B$1 = new WeakMap(),D$1 = T$1.createTreeWalker(T$1, 129, null, !1),q$1 = (t, i) => {const s = t.length - 1,e = [];let o,n = 2 === i ? "<svg>" : "",r = E$1;for (let i = 0; i < s; i++) {const s = t[i];let h,l,a = -1,u = 0;for (; u < s.length && (r.lastIndex = u, l = r.exec(s), null !== l);) u = r.lastIndex, r === E$1 ? "!--" === l[1] ? r = M$1 : void 0 !== l[1] ? r = U : void 0 !== l[2] ? (V$1.test(l[2]) && (o = RegExp("</" + l[2], "g")), r = N) : void 0 !== l[3] && (r = N) : r === N ? ">" === l[0] ? (r = null != o ? o : E$1, a = -1) : void 0 === l[1] ? a = -2 : (a = r.lastIndex - l[2].length, h = l[1], r = void 0 === l[3] ? N : '"' === l[3] ? O$1 : R$1) : r === O$1 || r === R$1 ? r = N : r === M$1 || r === U ? r = E$1 : (r = N, o = void 0);const c = r === N && t[i + 1].startsWith("/>") ? " " : "";n += r === E$1 ? s + C$1 : a >= 0 ? (e.push(h), s.slice(0, a) + "$lit$" + s.slice(a) + S$1 + c) : s + S$1 + (-2 === a ? (e.push(void 0), i) : c);}const h = n + (t[s] || "<?>") + (2 === i ? "</svg>" : "");if (!Array.isArray(t) || !t.hasOwnProperty("raw")) throw Error("invalid template strings array");return [void 0 !== w$1 ? w$1.createHTML(h) : h, e];};let J$1 = class J {constructor({ strings: t, _$litType$: i }, s) {let e;this.parts = [];let o = 0,n = 0;const r = t.length - 1,h = this.parts,[l, a] = q$1(t, i);if (this.el = J.createElement(l, s), D$1.currentNode = this.el.content, 2 === i) {const t = this.el.content,i = t.firstChild;i.remove(), t.append(...i.childNodes);}for (; null !== (e = D$1.nextNode()) && h.length < r;) {if (1 === e.nodeType) {if (e.hasAttributes()) {const t = [];for (const i of e.getAttributeNames()) if (i.endsWith("$lit$") || i.startsWith(S$1)) {const s = a[n++];if (t.push(i), void 0 !== s) {const t = e.getAttribute(s.toLowerCase() + "$lit$").split(S$1),i = /([.?@])?(.*)/.exec(s);h.push({ type: 1, index: o, name: i[2], strings: t, ctor: "." === i[1] ? K$1 : "?" === i[1] ? X$1 : "@" === i[1] ? Y$1 : G$1 });} else h.push({ type: 6, index: o });}for (const i of t) e.removeAttribute(i);}if (V$1.test(e.tagName)) {const t = e.textContent.split(S$1),i = t.length - 1;if (i > 0) {e.textContent = g$1 ? g$1.emptyScript : "";for (let s = 0; s < i; s++) e.append(t[s], P$1()), D$1.nextNode(), h.push({ type: 2, index: ++o });e.append(t[i], P$1());}}} else if (8 === e.nodeType) if (e.data === $$1) h.push({ type: 2, index: o });else {let t = -1;for (; -1 !== (t = e.data.indexOf(S$1, t + 1));) h.push({ type: 7, index: o }), t += S$1.length - 1;}o++;}}static createElement(t, i) {const s = T$1.createElement("template");return s.innerHTML = t, s;}};function W$1(t, i, s = t, e) {var o, n, r, h;if (i === I$1) return i;let l = void 0 !== e ? null === (o = s.A) || void 0 === o ? void 0 : o[e] : s.k;const a = x(i) ? void 0 : i._$litDirective$;return (null == l ? void 0 : l.constructor) !== a && (null === (n = null == l ? void 0 : l._$AO) || void 0 === n || n.call(l, !1), void 0 === a ? l = void 0 : (l = new a(t), l._$AT(t, s, e)), void 0 !== e ? (null !== (r = (h = s).A) && void 0 !== r ? r : h.A = [])[e] = l : s.k = l), void 0 !== l && (i = W$1(t, l._$AS(t, i.values), l, e)), i;}class Z {constructor(t, i) {this.M = [], this._$AN = void 0, this._$AD = t, this._$AM = i;}get parentNode() {return this._$AM.parentNode;}get _$AU() {return this._$AM._$AU;}U(t) {var i;const { el: { content: s }, parts: e } = this._$AD,o = (null !== (i = null == t ? void 0 : t.creationScope) && void 0 !== i ? i : T$1).importNode(s, !0);D$1.currentNode = o;let n = D$1.nextNode(),r = 0,h = 0,l = e[0];for (; void 0 !== l;) {if (r === l.index) {let i;2 === l.type ? i = new F$1(n, n.nextSibling, this, t) : 1 === l.type ? i = new l.ctor(n, l.name, l.strings, this, t) : 6 === l.type && (i = new tt$1(n, this, t)), this.M.push(i), l = e[++h];}r !== (null == l ? void 0 : l.index) && (n = D$1.nextNode(), r++);}return o;}N(t) {let i = 0;for (const s of this.M) void 0 !== s && (void 0 !== s.strings ? (s._$AI(t, s, i), i += s.strings.length - 2) : s._$AI(t[i])), i++;}}let F$1 = class F {constructor(t, i, s, e) {var o;this.type = 2, this._$AH = H$1, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this.R = null === (o = null == e ? void 0 : e.isConnected) || void 0 === o || o;}get _$AU() {var t, i;return null !== (i = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== i ? i : this.R;}get parentNode() {let t = this._$AA.parentNode;const i = this._$AM;return void 0 !== i && 11 === t.nodeType && (t = i.parentNode), t;}get startNode() {return this._$AA;}get endNode() {return this._$AB;}_$AI(t, i = this) {t = W$1(this, t, i), x(t) ? t === H$1 || null == t || "" === t ? (this._$AH !== H$1 && this._$AR(), this._$AH = H$1) : t !== this._$AH && t !== I$1 && this.O(t) : void 0 !== t._$litType$ ? this.V(t) : void 0 !== t.nodeType ? this.j(t) : k$1(t) ? this.L(t) : this.O(t);}I(t, i = this._$AB) {return this._$AA.parentNode.insertBefore(t, i);}j(t) {this._$AH !== t && (this._$AR(), this._$AH = this.I(t));}O(t) {this._$AH !== H$1 && x(this._$AH) ? this._$AA.nextSibling.data = t : this.j(T$1.createTextNode(t)), this._$AH = t;}V(t) {var i;const { values: s, _$litType$: e } = t,o = "number" == typeof e ? this._$AC(t) : (void 0 === e.el && (e.el = J$1.createElement(e.h, this.options)), e);if ((null === (i = this._$AH) || void 0 === i ? void 0 : i._$AD) === o) this._$AH.N(s);else {const t = new Z(o, this),i = t.U(this.options);t.N(s), this.j(i), this._$AH = t;}}_$AC(t) {let i = B$1.get(t.strings);return void 0 === i && B$1.set(t.strings, i = new J$1(t)), i;}L(t) {A$1(this._$AH) || (this._$AH = [], this._$AR());const i = this._$AH;let s,e = 0;for (const o of t) e === i.length ? i.push(s = new F(this.I(P$1()), this.I(P$1()), this, this.options)) : s = i[e], s._$AI(o), e++;e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e);}_$AR(t = this._$AA.nextSibling, i) {var s;for (null === (s = this._$AP) || void 0 === s || s.call(this, !1, !0, i); t && t !== this._$AB;) {const i = t.nextSibling;t.remove(), t = i;}}setConnected(t) {var i;void 0 === this._$AM && (this.R = t, null === (i = this._$AP) || void 0 === i || i.call(this, t));}};let G$1 = class G {constructor(t, i, s, e, o) {this.type = 1, this._$AH = H$1, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = o, s.length > 2 || "" !== s[0] || "" !== s[1] ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = H$1;}get tagName() {return this.element.tagName;}get _$AU() {return this._$AM._$AU;}_$AI(t, i = this, s, e) {const o = this.strings;let n = !1;if (void 0 === o) t = W$1(this, t, i, 0), n = !x(t) || t !== this._$AH && t !== I$1, n && (this._$AH = t);else {const e = t;let r, h;for (t = o[0], r = 0; r < o.length - 1; r++) h = W$1(this, e[s + r], i, r), h === I$1 && (h = this._$AH[r]), n || (n = !x(h) || h !== this._$AH[r]), h === H$1 ? t = H$1 : t !== H$1 && (t += (null != h ? h : "") + o[r + 1]), this._$AH[r] = h;}n && !e && this.H(t);}H(t) {t === H$1 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : "");}};let K$1 = class K extends G$1 {constructor() {super(...arguments), this.type = 3;}H(t) {this.element[this.name] = t === H$1 ? void 0 : t;}};const Q = g$1 ? g$1.emptyScript : "";let X$1 = class X extends G$1 {constructor() {super(...arguments), this.type = 4;}H(t) {t && t !== H$1 ? this.element.setAttribute(this.name, Q) : this.element.removeAttribute(this.name);}};let Y$1 = class Y extends G$1 {constructor(t, i, s, e, o) {super(t, i, s, e, o), this.type = 5;}_$AI(t, i = this) {var s;if ((t = null !== (s = W$1(this, t, i, 0)) && void 0 !== s ? s : H$1) === I$1) return;const e = this._$AH,o = t === H$1 && e !== H$1 || t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive,n = t !== H$1 && (e === H$1 || o);o && this.element.removeEventListener(this.name, this, e), n && this.element.addEventListener(this.name, this, t), this._$AH = t;}handleEvent(t) {var i, s;"function" == typeof this._$AH ? this._$AH.call(null !== (s = null === (i = this.options) || void 0 === i ? void 0 : i.host) && void 0 !== s ? s : this.element, t) : this._$AH.handleEvent(t);}};let tt$1 = class tt {constructor(t, i, s) {this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s;}get _$AU() {return this._$AM._$AU;}_$AI(t) {W$1(this, t);}};const st = b$1.litHtmlPolyfillSupport;null == st || st(J$1, F$1), (null !== (_$1 = b$1.litHtmlVersions) && void 0 !== _$1 ? _$1 : b$1.litHtmlVersions = []).push("2.6.1");const et$1 = (t, i, s) => {var e, o;const n = null !== (e = null == s ? void 0 : s.renderBefore) && void 0 !== e ? e : i;let r = n._$litPart$;if (void 0 === r) {const t = null !== (o = null == s ? void 0 : s.renderBefore) && void 0 !== o ? o : null;n._$litPart$ = r = new F$1(i.insertBefore(P$1(), t), t, void 0, null != s ? s : {});}return r._$AI(t), r;};
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */var ot, nt;class ht extends y {constructor() {super(...arguments), this.renderOptions = { host: this }, this.et = void 0;}createRenderRoot() {var t, i;const s = super.createRenderRoot();return null !== (t = (i = this.renderOptions).renderBefore) && void 0 !== t || (i.renderBefore = s.firstChild), s;}update(t) {const i = this.render();this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this.et = et$1(i, this.renderRoot, this.renderOptions);}connectedCallback() {var t;super.connectedCallback(), null === (t = this.et) || void 0 === t || t.setConnected(!0);}disconnectedCallback() {var t;super.disconnectedCallback(), null === (t = this.et) || void 0 === t || t.setConnected(!1);}render() {return I$1;}}ht.finalized = !0, ht._$litElement$ = !0, null === (ot = globalThis.litElementHydrateSupport) || void 0 === ot || ot.call(globalThis, { LitElement: ht });const lt$1 = globalThis.litElementPolyfillSupport;null == lt$1 || lt$1({ LitElement: ht });(null !== (nt = globalThis.litElementVersions) && void 0 !== nt ? nt : globalThis.litElementVersions = []).push("3.2.2");

/**
 * @module status-message
 */

// Web Components use classes

class StatusMessage extends ht {

	// these properties can be retrieved and assigned into; the TypeScript annotations
	// are a "Lit" requirement
  static properties = {
    text: {type: String},
  };

	// You can go bonkers with local styling; the CSS used here will not impact anything else
	// in the DOM but these components.
	static styles = [
		r`
			:host {
				display: block;
				color: #586c5c;
				font-family: monospace;
			}
		`
	];

	// all initialization happens here
	constructor() {
    super();
    this.text = '';
  }

  // whenever any of the properties change, this gets called
	render() {
		return z`<div>${crossOriginIsolated ? 'ðŸ”µ' : 'ðŸŒ•'} ${this.text}</div>`;
	}

}

// this registeres the component into the DOM
customElements.define('status-message', StatusMessage);

var D=(r=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(r,{get:(e,t)=>(typeof require!="undefined"?require:e)[t]}):r)(function(r){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+r+'" is not supported')});var ct=(r,e,t)=>{if(!e.has(r))throw TypeError("Cannot "+t)};var a=(r,e,t)=>(ct(r,e,"read from private field"),t?t.call(r):e.get(r)),u=(r,e,t)=>{if(e.has(r))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(r):e.set(r,t);},c=(r,e,t,n)=>(ct(r,e,"write to private field"),n?n.call(r,t):e.set(r,t),t);var w=(r,e,t)=>(ct(r,e,"access private method"),t);var b=typeof process<"u"&&process.release&&process.release.name==="node";if(globalThis.document);else if(globalThis.importScripts);else if(b);else throw new Error("Cannot determine runtime environment");function V(){let r={resolve:t=>{},reject:t=>{},promise:null},e=new Promise((t,n)=>{r.resolve=t,r.reject=n;});return r.promise=e,r}function Mt(r){return new Promise(e=>setTimeout(e,r))}function _(r,e,t,...n){return r===null||typeof r!="object"?r:e(r)?t(r,...n):Array.isArray(r)||ArrayBuffer.isView(r)?r.map(s=>_(s,e,t,...n)):Object.fromEntries(Object.entries(r).map(([s,o],l)=>[s,_(o,e,t,...n)]))}function Me(r,e){let t=new XMLHttpRequest;t.open("get",r,!0),t.onload=()=>{let n=new Worker(URL.createObjectURL(new Blob([t.responseText])));e(n);},t.send();}function H(r){if(b)return !1;let e=new URL(location.href),t=new URL(r,location.origin);return !(e.host===t.host&&e.port===t.port&&e.protocol===t.protocol)}var Rr=new WeakMap;function Dt(r,e){return Rr.set(r,e),r}var De=63;function Ae(){let r=Array.from({length:4},yr).join("-");if(r.length!==De)throw new Error("comlink internal error: UUID has the wrong length");return r}function yr(){let r=Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16),e=15-r.length;return e>0&&(r=Array.from({length:e},()=>0).join("")+r),r}function Ce(r,e){return At({type:"request",data:{uuid:Ae(),msg:r}},e)}function yt(r,e,t){return At({type:"response",data:{uuid:r,resp:e}},t)}function At(r,e){return e&&Dt(r,e),r}var dr=new TextEncoder;new TextDecoder("utf-8");function je(r){return dr.encode(JSON.stringify(r))}var hr=new TextEncoder;async function It(r,e,t){try{let{taskId:n,sizeBuffer:s,dataBuffer:o,signalBuffer:l}=e,p=je(t),y=p.length<=o.length;if(Atomics.store(s,0,p.length),Atomics.store(s,1,+y),!y){let[x,ae]=fr(r);o.set(hr.encode(x)),await jt(l,n),o=(await ae).dataBuffer;}o.set(p),Atomics.store(s,1,1),await jt(l,n);}catch(n){console.warn(n);}}function fr(r){let e=Ae();return [e,new Promise(t=>{b?r.once("message",n=>{!n.id||n.id!==e||t(n);}):r.addEventListener("message",function n(s){!s.data||!s.data.id||s.data.id!==e||(r.removeEventListener("message",n),t(s.data));}),r.start&&r.start();})]}async function jt(r,e){let t=(e>>1)%32,n=1;for(;Atomics.compareExchange(r,t+1,0,e)!==0;)await Mt(n),n<32&&(n*=2);Atomics.or(r,0,1<<t),Atomics.notify(r,0);}var W,S,oe,dt,G=class{constructor(){u(this,oe);u(this,W,void 0);u(this,S,void 0);c(this,S,[]),c(this,W,[]);}put(e){a(this,S).length||w(this,oe,dt).call(this),a(this,S).shift()(e);}async get(){return a(this,W).length||w(this,oe,dt).call(this),a(this,W).shift()}isEmpty(){return !a(this,W).length}isBlocked(){return !!a(this,S).length}get length(){return a(this,W).length-a(this,S).length}};W=new WeakMap,S=new WeakMap,oe=new WeakSet,dt=function(){a(this,W).push(new Promise(e=>{a(this,S).push(e);}));};function Nt(r){let e=new Error(r.obj.message);return e.name=r.obj.name,e.stack=r.obj.stack,e}function br(r){return r&&typeof r=="object"&&"payloadType"in r&&"obj"in r}function Fe(r){return br(r)&&r.payloadType==="ptr"}var $,X=class{constructor(){this.inputQueue=new G;this.outputQueue=new G;this.systemQueue=new G;u(this,$,new Map);}async read(){return await this.outputQueue.get()}async flush(){let e=[];for(;!this.outputQueue.isEmpty();)e.push(await this.read());return e}async readSystem(){return await this.systemQueue.get()}write(e){this.inputQueue.put(e);}async request(e,t){let n=Ce(e,t),{resolve:s,reject:o,promise:l}=V();return a(this,$).set(n.data.uuid,{resolve:s,reject:o}),this.write(n),l}resolveResponse(e){let t=e.data.uuid,n=a(this,$).get(t);if(n){let s=e.data.resp;a(this,$).delete(t),s.payloadType==="err"?n.reject(Nt(s)):n.resolve(s);}else console.warn("Can't find request.");}};$=new WeakMap;new TextDecoder("utf-8");var i={};function qt(r){Object.keys(r).forEach(e=>i._free(r[e]));}b&&(globalThis.Worker=D("worker_threads").Worker);var K,qe,Jt,ue,pe=class extends X{constructor(t){super();u(this,qe);u(this,K,void 0);this.close=()=>{};u(this,ue,async(t,n)=>{if(!(!n||!n.type))switch(n.type){case"resolve":c(this,K,new Int32Array(n.data)),this.resolve();return;case"response":this.resolveResponse(n);return;case"system":this.systemQueue.put(n.data);return;default:this.outputQueue.put(n);return;case"sync-request":{let s=n,o=s.data.msg,l=s.data.reqData;switch(o.type){case"read":{let p=await this.inputQueue.get();await It(t,l,p);break}default:throw new TypeError(`Unsupported request type '${o.type}'.`)}return}case"request":throw new TypeError("Can't send messages of type 'request' from a worker. Please Use 'sync-request' instead.")}});let n=s=>{w(this,qe,Jt).call(this,s),this.close=()=>s.terminate();let o={type:"init",data:{config:t,channelType:O.SharedArrayBuffer}};s.postMessage(o);};if(H(t.baseUrl))Me(`${t.baseUrl}webr-worker.js`,s=>n(s));else {let s=new Worker(`${t.baseUrl}webr-worker.js`);n(s);}({resolve:this.resolve,promise:this.initialised}=V());}interrupt(){if(!a(this,K))throw new Error("Failed attempt to interrupt before initialising interruptBuffer");a(this,K)[0]=1;}};K=new WeakMap,qe=new WeakSet,Jt=function(t){b?t.on("message",n=>{a(this,ue).call(this,t,n);}):t.onmessage=n=>a(this,ue).call(this,t,n.data);},ue=new WeakMap;b&&(globalThis.Worker=D("worker_threads").Worker);var Y,F,ee,Je,Vt,Ve,Ht,He,Gt,de,ye=class extends X{constructor(t){super();u(this,Je);u(this,Ve);u(this,He);this.close=()=>{};u(this,Y,new Map);u(this,F,void 0);u(this,ee,!1);u(this,de,async(t,n)=>{if(!(!n||!n.type))switch(n.type){case"resolve":this.resolve();return;case"response":this.resolveResponse(n);return;case"system":this.systemQueue.put(n.data);return;default:this.outputQueue.put(n);return;case"sync-request":{let s=n.data;a(this,Y).set(s.data.uuid,s.data.msg);return}case"request":throw new TypeError("Can't send messages of type 'request' from a worker.Use service worker fetch request instead.")}});let n=s=>{w(this,He,Gt).call(this,s),this.close=()=>s.terminate(),w(this,Je,Vt).call(this,`${t.serviceWorkerUrl}webr-serviceworker.js`).then(o=>{let l={type:"init",data:{config:t,channelType:O.ServiceWorker,clientId:o,location:window.location.href}};s.postMessage(l);});};if(H(t.serviceWorkerUrl))Me(`${t.serviceWorkerUrl}webr-worker.js`,s=>n(s));else {let s=new Worker(`${t.serviceWorkerUrl}webr-worker.js`);n(s);}({resolve:this.resolve,promise:this.initialised}=V());}activeRegistration(){var t;if(!((t=a(this,F))!=null&&t.active))throw new Error("Attempted to obtain a non-existent active registration.");return a(this,F).active}interrupt(){c(this,ee,!0);}};Y=new WeakMap,F=new WeakMap,ee=new WeakMap,Je=new WeakSet,Vt=async function(t){c(this,F,await navigator.serviceWorker.register(t)),await navigator.serviceWorker.ready,window.addEventListener("beforeunload",()=>{var s;(s=a(this,F))==null||s.unregister();});let n=await new Promise(s=>{navigator.serviceWorker.addEventListener("message",function o(l){l.data.type==="registration-successful"&&(navigator.serviceWorker.removeEventListener("message",o),s(l.data.clientId));}),this.activeRegistration().postMessage({type:"register-client-main"});});return navigator.serviceWorker.addEventListener("message",s=>{w(this,Ve,Ht).call(this,s);}),n},Ve=new WeakSet,Ht=async function(t){if(t.data.type==="request"){let n=t.data.data,s=a(this,Y).get(n);if(!s)throw new Error("Request not found during service worker XHR request");switch(a(this,Y).delete(n),s.type){case"read":{let o=await this.inputQueue.get();this.activeRegistration().postMessage({type:"wasm-webr-fetch-response",uuid:n,response:yt(n,o)});break}case"interrupt":{let o=a(this,ee);this.activeRegistration().postMessage({type:"wasm-webr-fetch-response",uuid:n,response:yt(n,o)}),c(this,ee,!1);break}default:throw new TypeError(`Unsupported request type '${s.type}'.`)}return}},He=new WeakSet,Gt=function(t){b?t.on("message",n=>{a(this,de).call(this,t,n);}):t.onmessage=n=>a(this,de).call(this,t,n.data);},de=new WeakMap;var O={Automatic:0,SharedArrayBuffer:1,ServiceWorker:2};function $t(r){switch(r.channelType){case O.SharedArrayBuffer:return new pe(r);case O.ServiceWorker:return new ye(r);case O.Automatic:default:if(typeof SharedArrayBuffer<"u")return new pe(r);if("serviceWorker"in navigator&&!H(r.serviceWorkerUrl))return new ye(r);throw new Error("Can't initialise main thread communication channel")}}var Xt=b?__dirname+"/":"https://webr.r-wasm.org/main/",zt="https://repo.r-wasm.org";function M(r){return r&&(typeof r=="object"||typeof r=="function")&&"payloadType"in r&&Fe(r._payload)}function Qt(r){var e;return Boolean(M(r)&&((e=r._payload.obj.methods)==null?void 0:e.includes("exec")))}var d={null:0,symbol:1,pairlist:2,closure:3,environment:4,promise:5,call:6,special:7,builtin:8,string:9,logical:10,integer:13,double:14,complex:15,character:16,dots:17,any:18,list:19,expression:20,bytecode:21,pointer:22,weakref:23,raw:24,s4:25,new:30,free:31,function:99};function gt(r){return r&&typeof r=="object"&&Object.keys(d).includes(r.type)}function wt(r){return r&&typeof r=="object"&&"re"in r&&"im"in r}function Ge(r){return i._Rf_protect(k(r)),r}function P(r,e){return i._Rf_protect(k(r)),++e.n,r}function Zt(r){let e=i._malloc(4);return i._R_ProtectWithIndex(k(r),e),{loc:i.getValue(e,"i32"),ptr:e}}function Kt(r){i._Rf_unprotect(1),i._free(r.ptr);}function Yt(r,e){return i._R_Reprotect(k(r),e.loc),r}function T(r){i._Rf_unprotect(r);}function Pt(r,e,t){i._Rf_defineVar(k(e),k(t),k(r));}function er(r,e){let t={},n={n:0};try{let s=new we(e);P(s,n),t.code=i.allocateUTF8(r);let o=i._R_ParseEvalString(t.code,s.ptr);return R.wrap(o)}finally{qt(t),T(n.n);}}function ge(r,e){return i.LDSO.loadedLibsByName["/usr/lib/R/library/webr/libs/webr.so"].module.ffi_safe_eval(k(r),k(e))}function k(r){return Er(r)?r.ptr:r}function J(r,e){if(i._TYPEOF(r.ptr)!==d[e])throw new Error(`Unexpected object type "${r.type()}" when expecting type "${e}"`)}function xr(r){if(gt(r))return new(tr(d[r.type]))(r);if(r&&typeof r=="object"&&"type"in r&&r.type==="null")return new Qe;if(r===null)return new B({type:"logical",names:null,values:[null]});if(typeof r=="boolean")return new B(r);if(typeof r=="number")return new Pe(r);if(typeof r=="string")return new A(r);if(wt(r))return new ve(r);if(Array.isArray(r))return Tr(r);throw new Error("Robj construction for this JS object is not yet supported")}function Tr(r){let e={n:0};try{let t=new q([new C("c"),...r]);return P(t,e),t.eval()}finally{T(e.n);}}var g=class{constructor(e){this.ptr=e;}type(){let e=i._TYPEOF(this.ptr);return Object.keys(d).find(n=>d[n]===e)}},ne,$e,L=class extends g{constructor(t){if(!(t instanceof g))return xr(t);super(t.ptr);u(this,ne);}static wrap(t){let n=i._TYPEOF(t);return new(tr(n))(new g(t))}get[Symbol.toStringTag](){return `RObject:${this.type()}`}static getPersistentObject(t){return v[t]}getPropertyValue(t){return this[t]}inspect(){er(".Internal(inspect(x))",{x:this});}isNull(){return i._TYPEOF(this.ptr)===d.null}isUnbound(){return this.ptr===v.unboundValue.ptr}attrs(){return se.wrap(i._ATTRIB(this.ptr))}setNames(t){let n;if(t===null)n=v.null;else if(Array.isArray(t)&&t.every(s=>typeof s=="string"||s===null))n=new A(t);else throw new Error("Argument to setNames must be null or an Array of strings or null");return i._Rf_setAttrib(this.ptr,v.namesSymbol.ptr,n.ptr),this}names(){let t=A.wrap(i._Rf_getAttrib(this.ptr,v.namesSymbol.ptr));return t.isNull()?null:t.toArray()}includes(t){let n=this.names();return n&&n.includes(t)}toJs(t={depth:0},n=1){throw new Error("This R object cannot be converted to JS")}subset(t){return w(this,ne,$e).call(this,t,v.bracketSymbol.ptr)}get(t){return w(this,ne,$e).call(this,t,v.bracket2Symbol.ptr)}getDollar(t){return w(this,ne,$e).call(this,t,v.dollarSymbol.ptr)}pluck(...t){let n=Zt(v.null);try{let s=(l,p)=>{let y=l.get(p);return Yt(y,n)},o=t.reduce(s,this);return o.isNull()?void 0:o}finally{Kt(n);}}set(t,n){let s={n:0};try{let o=new L(t);P(o,s);let l=new L(n);P(l,s);let p=new C("[[<-"),y=i._Rf_lang4(p.ptr,this.ptr,o.ptr,l.ptr);return P(y,s),L.wrap(ge(y,v.baseEnv))}finally{T(s.n);}}static getMethods(t){let n=new Set,s=t;do Object.getOwnPropertyNames(s).map(o=>n.add(o));while(s=Object.getPrototypeOf(s));return [...n.keys()].filter(o=>typeof t[o]=="function")}},R=L;ne=new WeakSet,$e=function(t,n){let s={n:0};try{let o=new L(t);P(o,s);let l=i._Rf_lang3(n,this.ptr,o.ptr);return P(l,s),L.wrap(ge(l,v.baseEnv))}finally{T(s.n);}};var Qe=class extends R{constructor(){return super(new g(i.getValue(i._R_NilValue,"*"))),this}toJs(){return {type:"null"}}},C=class extends R{constructor(e){if(e instanceof g){J(e,"symbol"),super(e);return}let t=i.allocateUTF8(e);try{super(new g(i._Rf_install(t)));}finally{i._free(t);}}toJs(){let e=this.toObject();return {type:"symbol",printname:e.printname,symvalue:e.symvalue,internal:e.internal}}toObject(){return {printname:this.printname().isUnbound()?null:this.printname().toString(),symvalue:this.symvalue().isUnbound()?null:this.symvalue().ptr,internal:this.internal().isNull()?null:this.internal().ptr}}toString(){return this.printname().toString()}printname(){return xe.wrap(i._PRINTNAME(this.ptr))}symvalue(){return R.wrap(i._SYMVALUE(this.ptr))}internal(){return R.wrap(i._INTERNAL(this.ptr))}},se=class extends R{constructor(e){if(e instanceof g)return J(e,"pairlist"),super(e),this;let t={n:0};try{let{names:n,values:s}=Te(e),o=se.wrap(i._Rf_allocList(s.length));P(o,t);for(let[l,p]=[0,o];!p.isNull();[l,p]=[l+1,p.cdr()])p.setcar(new R(s[l]));o.setNames(n),super(o);}finally{T(t.n);}}get length(){return this.toArray().length}toArray(e={depth:1}){return this.toJs(e).values}toObject({allowDuplicateKey:e=!0,allowEmptyKey:t=!1,depth:n=1}={}){let s=this.entries({depth:n}),o=s.map(([l,p])=>l);if(!e&&new Set(o).size!==o.length)throw new Error("Duplicate key when converting pairlist without allowDuplicateKey enabled");if(!t&&o.some(l=>!l))throw new Error("Empty or null key when converting pairlist without allowEmptyKey enabled");return Object.fromEntries(s.filter((l,p)=>s.findIndex(y=>y[0]===l[0])===p))}entries(e={depth:1}){let t=this.toJs(e);return t.values.map((n,s)=>[t.names?t.names[s]:null,n])}toJs(e={depth:0},t=1){let n=[],s=!1,o=[];for(let p=this;!p.isNull();p=p.cdr()){let y=p.tag();y.isNull()?n.push(""):(s=!0,n.push(y.toString())),e.depth&&t>=e.depth?o.push(p.car()):o.push(p.car().toJs(e,t+1));}return {type:"pairlist",names:s?n:null,values:o}}includes(e){return e in this.toObject()}setcar(e){i._SETCAR(this.ptr,e.ptr);}car(){return R.wrap(i._CAR(this.ptr))}cdr(){return R.wrap(i._CDR(this.ptr))}tag(){return R.wrap(i._TAG(this.ptr))}},q=class extends R{constructor(e){if(e instanceof g)return J(e,"call"),super(e),this;let t={n:0};try{let{values:n}=Te(e),s=n.map(l=>P(new R(l),t)),o=q.wrap(i._Rf_allocVector(d.call,n.length));P(o,t);for(let[l,p]=[0,o];!p.isNull();[l,p]=[l+1,p.cdr()])p.setcar(s[l]);super(o);}finally{T(t.n);}}setcar(e){i._SETCAR(this.ptr,e.ptr);}car(){return R.wrap(i._CAR(this.ptr))}cdr(){return R.wrap(i._CDR(this.ptr))}eval(){return R.wrap(ge(this.ptr,v.baseEnv))}},vt=class extends R{constructor(e){if(e instanceof g)return J(e,"list"),super(e),this;let t={n:0};try{let{names:n,values:s}=Te(e),o=i._Rf_allocVector(d.list,s.length);P(o,t),s.forEach((l,p)=>{i._SET_VECTOR_ELT(o,p,new R(l).ptr);}),R.wrap(o).setNames(n),super(new g(o));}finally{T(t.n);}}get length(){return i._LENGTH(this.ptr)}toArray(e={depth:1}){return this.toJs(e).values}toObject({allowDuplicateKey:e=!0,allowEmptyKey:t=!1,depth:n=1}={}){let s=this.entries({depth:n}),o=s.map(([l,p])=>l);if(!e&&new Set(o).size!==o.length)throw new Error("Duplicate key when converting list without allowDuplicateKey enabled");if(!t&&o.some(l=>!l))throw new Error("Empty or null key when converting list without allowEmptyKey enabled");return Object.fromEntries(s.filter((l,p)=>s.findIndex(y=>y[0]===l[0])===p))}entries(e={depth:1}){let t=this.toJs(e);return t.values.map((n,s)=>[t.names?t.names[s]:null,n])}toJs(e={depth:0},t=1){return {type:"list",names:this.names(),values:[...Array(this.length).keys()].map(n=>e.depth&&t>=e.depth?this.get(n+1):this.get(n+1).toJs(e,t+1))}}},re=class extends R{exec(...e){let t={n:0};try{let n=new q([this,...e]);return P(n,t),n.eval()}finally{T(t.n);}}},xe=class extends R{constructor(e){if(e instanceof g){J(e,"string"),super(e);return}let t=i.allocateUTF8(e);try{super(new g(i._Rf_mkChar(t)));}finally{i._free(t);}}toString(){return i.UTF8ToString(i._R_CHAR(this.ptr))}toJs(){return {type:"string",value:this.toString()}}},we=class extends R{constructor(e={}){if(e instanceof g)return J(e,"environment"),super(e),this;let t=0;try{let{names:n,values:s}=Te(e),o=Ge(i._R_NewEnv(v.globalEnv.ptr,0,0));++t,s.forEach((l,p)=>{let y=n?n[p]:null;if(!y)throw new Error("Can't create object in new environment with empty symbol name");let x=new C(y),ae=Ge(new R(l));try{Pt(o,x,ae);}finally{T(1);}}),super(new g(o));}finally{T(t);}}ls(e=!1,t=!0){return A.wrap(i._R_lsInternal3(this.ptr,Number(e),Number(t))).toArray()}bind(e,t){let n=new C(e),s=Ge(new R(t));try{Pt(this,n,s);}finally{T(1);}}names(){return this.ls(!0,!0)}frame(){return R.wrap(i._FRAME(this.ptr))}subset(e){if(typeof e=="number")throw new Error("Object of type environment is not subsettable");return this.getDollar(e)}toObject({depth:e=0}={}){let t=this.names();return Object.fromEntries([...Array(t.length).keys()].map(n=>[t[n],this.getDollar(t[n]).toJs({depth:e})]))}toJs(e={depth:0},t=1){let n=this.names(),s=[...Array(n.length).keys()].map(o=>e.depth&&t>=e.depth?this.getDollar(n[o]):this.getDollar(n[o]).toJs(e,t+1));return {type:"environment",names:n,values:s}}},j=class extends R{constructor(e,t,n){if(e instanceof g)return J(e,t),super(e),this;let s={n:0};try{let{names:o,values:l}=Te(e),p=i._Rf_allocVector(d[t],l.length);P(p,s),l.forEach(n(p)),R.wrap(p).setNames(o),super(new g(p));}finally{T(s.n);}}get length(){return i._LENGTH(this.ptr)}get(e){return super.get(e)}subset(e){return super.subset(e)}getDollar(e){throw new Error("$ operator is invalid for atomic vectors")}detectMissing(){let e={n:0};try{let t=i._Rf_lang2(new C("is.na").ptr,this.ptr);P(t,e);let n=B.wrap(ge(t,v.baseEnv));P(n,e);let s=n.toTypedArray();return Array.from(s).map(o=>Boolean(o))}finally{T(e.n);}}toArray(){let e=this.toTypedArray();return this.detectMissing().map((t,n)=>t?null:e[n])}toObject({allowDuplicateKey:e=!0,allowEmptyKey:t=!1}={}){let n=this.entries(),s=n.map(([o,l])=>o);if(!e&&new Set(s).size!==s.length)throw new Error("Duplicate key when converting atomic vector without allowDuplicateKey enabled");if(!t&&s.some(o=>!o))throw new Error("Empty or null key when converting atomic vector without allowEmptyKey enabled");return Object.fromEntries(n.filter((o,l)=>n.findIndex(p=>p[0]===o[0])===l))}entries(){let e=this.toArray(),t=this.names();return e.map((n,s)=>[t?t[s]:null,n])}toJs(){return {type:this.type(),names:this.names(),values:this.toArray()}}},Ze,xt=class extends j{constructor(e){super(e,"logical",a(xt,Ze));}getBoolean(e){return this.get(e).toArray()[0]}toBoolean(){if(this.length!==1)throw new Error("Can't convert atomic vector of length > 1 to a scalar JS value");let e=this.getBoolean(1);if(e===null)throw new Error("Can't convert missing value `NA` to a JS boolean");return e}toTypedArray(){return new Int32Array(i.HEAP32.subarray(i._LOGICAL(this.ptr)/4,i._LOGICAL(this.ptr)/4+this.length))}toArray(){let e=this.toTypedArray();return this.detectMissing().map((t,n)=>t?null:Boolean(e[n]))}},B=xt;Ze=new WeakMap,u(B,Ze,e=>{let t=i._LOGICAL(e),n=i.getValue(i._R_NaInt,"i32");return (s,o)=>{i.setValue(t+4*o,s===null?n:Boolean(s),"i32");}});var Ke,Tt=class extends j{constructor(e){super(e,"integer",a(Tt,Ke));}getNumber(e){return this.get(e).toArray()[0]}toNumber(){if(this.length!==1)throw new Error("Can't convert atomic vector of length > 1 to a scalar JS value");let e=this.getNumber(1);if(e===null)throw new Error("Can't convert missing value `NA` to a JS number");return e}toTypedArray(){return new Int32Array(i.HEAP32.subarray(i._INTEGER(this.ptr)/4,i._INTEGER(this.ptr)/4+this.length))}},Xe=Tt;Ke=new WeakMap,u(Xe,Ke,e=>{let t=i._INTEGER(e),n=i.getValue(i._R_NaInt,"i32");return (s,o)=>{i.setValue(t+4*o,s===null?n:Math.round(Number(s)),"i32");}});var Ye,Et=class extends j{constructor(e){super(e,"double",a(Et,Ye));}getNumber(e){return this.get(e).toArray()[0]}toNumber(){if(this.length!==1)throw new Error("Can't convert atomic vector of length > 1 to a scalar JS value");let e=this.getNumber(1);if(e===null)throw new Error("Can't convert missing value `NA` to a JS number");return e}toTypedArray(){return new Float64Array(i.HEAPF64.subarray(i._REAL(this.ptr)/8,i._REAL(this.ptr)/8+this.length))}},Pe=Et;Ye=new WeakMap,u(Pe,Ye,e=>{let t=i._REAL(e),n=i.getValue(i._R_NaReal,"double");return (s,o)=>{i.setValue(t+8*o,s===null?n:s,"double");}});var et,_t=class extends j{constructor(e){super(e,"complex",a(_t,et));}getComplex(e){return this.get(e).toArray()[0]}toComplex(){if(this.length!==1)throw new Error("Can't convert atomic vector of length > 1 to a scalar JS value");let e=this.getComplex(1);if(e===null)throw new Error("Can't convert missing value `NA` to a JS object");return e}toTypedArray(){return new Float64Array(i.HEAPF64.subarray(i._COMPLEX(this.ptr)/8,i._COMPLEX(this.ptr)/8+2*this.length))}toArray(){let e=this.toTypedArray();return this.detectMissing().map((t,n)=>t?null:{re:e[2*n],im:e[2*n+1]})}},ve=_t;et=new WeakMap,u(ve,et,e=>{let t=i._COMPLEX(e),n=i.getValue(i._R_NaReal,"double");return (s,o)=>{i.setValue(t+8*(2*o),s===null?n:s.re,"double"),i.setValue(t+8*(2*o+1),s===null?n:s.im,"double");}});var tt,kt=class extends j{constructor(e){super(e,"character",a(kt,tt));}getString(e){return this.get(e).toArray()[0]}toString(){if(this.length!==1)throw new Error("Can't convert atomic vector of length > 1 to a scalar JS value");let e=this.getString(1);if(e===null)throw new Error("Can't convert missing value `NA` to a JS string");return e}toTypedArray(){return new Uint32Array(i.HEAPU32.subarray(i._STRING_PTR(this.ptr)/4,i._STRING_PTR(this.ptr)/4+this.length))}toArray(){return this.detectMissing().map((e,t)=>e?null:i.UTF8ToString(i._R_CHAR(i._STRING_ELT(this.ptr,t))))}},A=kt;tt=new WeakMap,u(A,tt,e=>(t,n)=>{t===null?i._SET_STRING_ELT(e,n,v.naString.ptr):i._SET_STRING_ELT(e,n,new xe(t).ptr);});var rt,Wt=class extends j{constructor(e){super(e,"raw",a(Wt,rt));}getNumber(e){return this.get(e).toArray()[0]}toNumber(){if(this.length!==1)throw new Error("Can't convert atomic vector of length > 1 to a scalar JS value");let e=this.getNumber(1);if(e===null)throw new Error("Can't convert missing value `NA` to a JS number");return e}toTypedArray(){return new Uint8Array(i.HEAPU8.subarray(i._RAW(this.ptr),i._RAW(this.ptr)+this.length))}},ze=Wt;rt=new WeakMap,u(ze,rt,e=>{let t=i._RAW(e);return (n,s)=>{i.setValue(t+s,Number(n),"i8");}});function Te(r){return gt(r)?r:Array.isArray(r)?{names:null,values:r}:r&&typeof r=="object"&&!wt(r)?{names:Object.keys(r),values:Object.values(r)}:{names:null,values:[r]}}function tr(r){let e={[d.null]:Qe,[d.symbol]:C,[d.pairlist]:se,[d.closure]:re,[d.environment]:we,[d.call]:q,[d.special]:re,[d.builtin]:re,[d.string]:xe,[d.logical]:B,[d.integer]:Xe,[d.double]:Pe,[d.complex]:ve,[d.character]:A,[d.list]:vt,[d.raw]:ze,[d.function]:re};return r in e?e[r]:R}function Er(r){return r instanceof R}var v;function kr(){}function Wr(r,e){return async function*(){let t={type:"callRObjectMethod",data:{payload:e._payload,prop:"getPropertyValue",args:[{payloadType:"raw",obj:"length"}],shelter:void 0}},n=await r.request(t);if(typeof n.obj!="number")throw new Error("Cannot iterate over object, unexpected type for length property.");for(let s=1;s<=n.obj;s++)yield e.get(s);}}function rr(r,e,t){return async(...n)=>{let s=n.map(p=>M(p)?p._payload:{obj:_(p,M,y=>y._payload),payloadType:"raw"}),o={type:"callRObjectMethod",data:{payload:t,prop:e,args:s}},l=await r.request(o);switch(l.payloadType){case"ptr":return I(r,l);case"raw":return _(l,Fe,(y,x)=>I(x,y),r).obj}}}async function Sr(r,e,t,n){let s={type:"newRObject",data:{objType:e,obj:_(n,M,l=>l._payload),shelter:t}},o=await r.request(s);switch(o.payloadType){case"raw":throw new Error("Unexpected raw payload type returned from newRObject");case"ptr":return I(r,o)}}function I(r,e){var n;let t=new Proxy((n=e.obj.methods)!=null&&n.includes("exec")?Object.assign(kr,{...e}):e,{get:(s,o)=>{var l;if(o==="_payload")return e;if(o===Symbol.asyncIterator)return Wr(r,t);if((l=e.obj.methods)!=null&&l.includes(o.toString()))return rr(r,o.toString(),e)},apply:async(s,o,l)=>{let p=await I(r,e).exec(...l);return Qt(p)?p:p.toJs()}});return t}function E(r,e,t){return new Proxy(R,{construct:(n,s)=>Sr(r,t,e,...s),get:(n,s)=>rr(r,s.toString())})}var Or={R_HOME:"/usr/lib/R",R_ENABLE_JIT:"0"},Mr={RArgs:[],REnv:Or,baseUrl:Xt,serviceWorkerUrl:"",repoUrl:zt,homedir:"/home/web_user",interactive:!0,channelType:O.Automatic},f,ut,sr,lt=class{constructor(e={}){u(this,ut);u(this,f,void 0);this.FS={lookupPath:async e=>{let t={type:"lookupPath",data:{path:e}};return (await a(this,f).request(t)).obj},mkdir:async e=>{let t={type:"mkdir",data:{path:e}};return (await a(this,f).request(t)).obj},readFile:async(e,t)=>{let n={type:"readFile",data:{path:e,flags:t}};return (await a(this,f).request(n)).obj},rmdir:async e=>{let t={type:"rmdir",data:{path:e}};await a(this,f).request(t);},writeFile:async(e,t,n)=>{let s={type:"writeFile",data:{path:e,data:t,flags:n}};await a(this,f).request(s);},unlink:async e=>{let t={type:"unlink",data:{path:e}};await a(this,f).request(t);}};let t=Object.assign(Mr,e);c(this,f,$t(t)),this.objs={},this.Shelter=Dr(a(this,f));}async init(){let e=await a(this,f).initialised;return this.globalShelter=await new this.Shelter,this.RObject=this.globalShelter.RObject,this.RLogical=this.globalShelter.RLogical,this.RInteger=this.globalShelter.RInteger,this.RDouble=this.globalShelter.RDouble,this.RComplex=this.globalShelter.RComplex,this.RCharacter=this.globalShelter.RCharacter,this.RRaw=this.globalShelter.RRaw,this.RList=this.globalShelter.RList,this.RPairlist=this.globalShelter.RPairlist,this.REnvironment=this.globalShelter.REnvironment,this.RSymbol=this.globalShelter.RSymbol,this.RString=this.globalShelter.RString,this.RCall=this.globalShelter.RCall,this.objs={baseEnv:await this.RObject.getPersistentObject("baseEnv"),globalEnv:await this.RObject.getPersistentObject("globalEnv"),null:await this.RObject.getPersistentObject("null"),true:await this.RObject.getPersistentObject("true"),false:await this.RObject.getPersistentObject("false"),na:await this.RObject.getPersistentObject("na")},w(this,ut,sr).call(this),e}close(){a(this,f).close();}async read(){return await a(this,f).read()}async flush(){return await a(this,f).flush()}write(e){a(this,f).write(e);}writeConsole(e){this.write({type:"stdin",data:e+`
`});}interrupt(){a(this,f).interrupt();}async installPackages(e){for(let t of e){let n={type:"installPackage",data:{name:t}};await a(this,f).request(n);}}async destroy(e){await this.globalShelter.destroy(e);}async evalR(e,t){return this.globalShelter.evalR(e,t)}async evalRVoid(e,t){return this.evalRRaw(e,"void",t)}async evalRBoolean(e,t){return this.evalRRaw(e,"boolean",t)}async evalRNumber(e,t){return this.evalRRaw(e,"number",t)}async evalRString(e,t){return this.evalRRaw(e,"string",t)}async evalRRaw(e,t,n={}){let s=_(n,M,p=>p._payload),o={type:"evalRRaw",data:{code:e,options:s,outputType:t}},l=await a(this,f).request(o);switch(l.payloadType){case"raw":return l.obj;case"ptr":throw new Error("Unexpected ptr payload type returned from evalRVoid")}}async invokeWasmFunction(e,...t){let n={type:"invokeWasmFunction",data:{ptr:e,args:t}};return (await a(this,f).request(n)).obj}};f=new WeakMap,ut=new WeakSet,sr=async function(){for(;;){let e=await a(this,f).readSystem();switch(e.type){case"setTimeoutWasm":setTimeout((t,n)=>{this.invokeWasmFunction(t,...n);},e.data.delay,e.data.ptr,e.data.args);break;default:throw new Error("Unknown system message type `"+e.type+"`")}}};var h,m,Se,pt=class{constructor(e){u(this,h,"");u(this,m,void 0);u(this,Se,!1);c(this,m,e);}async init(){if(a(this,Se))return;let e={type:"newShelter"},t=await a(this,m).request(e);c(this,h,t.obj),this.RObject=E(a(this,m),a(this,h),"object"),this.RLogical=E(a(this,m),a(this,h),"logical"),this.RInteger=E(a(this,m),a(this,h),"integer"),this.RDouble=E(a(this,m),a(this,h),"double"),this.RComplex=E(a(this,m),a(this,h),"complex"),this.RCharacter=E(a(this,m),a(this,h),"character"),this.RRaw=E(a(this,m),a(this,h),"raw"),this.RList=E(a(this,m),a(this,h),"list"),this.RPairlist=E(a(this,m),a(this,h),"pairlist"),this.REnvironment=E(a(this,m),a(this,h),"environment"),this.RSymbol=E(a(this,m),a(this,h),"symbol"),this.RString=E(a(this,m),a(this,h),"string"),this.RCall=E(a(this,m),a(this,h),"call"),c(this,Se,!0);}async purge(){let e={type:"shelterPurge",data:a(this,h)};await a(this,m).request(e);}async destroy(e){let t={type:"shelterDestroy",data:{id:a(this,h),obj:e._payload}};await a(this,m).request(t);}async size(){let e={type:"shelterSize",data:a(this,h)};return (await a(this,m).request(e)).obj}async evalR(e,t={}){let n=_(t,M,l=>l._payload),s={type:"evalR",data:{code:e,options:n,shelter:a(this,h)}},o=await a(this,m).request(s);switch(o.payloadType){case"raw":throw new Error("Unexpected payload type returned from evalR");default:return I(a(this,m),o)}}async captureR(e,t={}){let n=_(t,M,l=>l._payload),s={type:"captureR",data:{code:e,options:n,shelter:a(this,h)}},o=await a(this,m).request(s);switch(o.payloadType){case"ptr":throw new Error("Unexpected payload type returned from evalR");case"raw":{let l=o.obj,p=I(a(this,m),l.result),y=l.output;for(let x=0;x<y.length;++x)y[x].type!=="stdout"&&y[x].type!=="stderr"&&(y[x].data=I(a(this,m),y[x].data));return {result:p,output:y}}}}};h=new WeakMap,m=new WeakMap,Se=new WeakMap;function Dr(r){return new Proxy(pt,{construct:async()=>{let e=new pt(r);return await e.init(),e}})}

/**
 * R Stuff
 * 
 * @module rstuff
 */

globalThis.webR = new lt();

await globalThis.webR.init();

const webR$1 = globalThis.webR;

await webR$1.evalR('library');

var StackFrame,FIREFOX_SAFARI_STACK_REGEXP,CHROME_IE_STACK_REGEXP,SAFARI_NATIVE_CODE_REGEXP,stackframe = { exports: {} };stackframe.exports = function () {function _isNumber(n) {return !isNaN(parseFloat(n)) && isFinite(n);}function _capitalize(str) {return str.charAt(0).toUpperCase() + str.substring(1);}function _getter(p) {return function () {return this[p];};}var booleanProps = ["isConstructor", "isEval", "isNative", "isToplevel"],numericProps = ["columnNumber", "lineNumber"],stringProps = ["fileName", "functionName", "source"],arrayProps = ["args"],objectProps = ["evalOrigin"],props = booleanProps.concat(numericProps, stringProps, arrayProps, objectProps);function StackFrame(obj) {if (obj) for (var i = 0; i < props.length; i++) void 0 !== obj[props[i]] && this["set" + _capitalize(props[i])](obj[props[i]]);}StackFrame.prototype = { getArgs: function () {return this.args;}, setArgs: function (v) {if ("[object Array]" !== Object.prototype.toString.call(v)) throw new TypeError("Args must be an Array");this.args = v;}, getEvalOrigin: function () {return this.evalOrigin;}, setEvalOrigin: function (v) {if (v instanceof StackFrame) this.evalOrigin = v;else {if (!(v instanceof Object)) throw new TypeError("Eval Origin must be an Object or StackFrame");this.evalOrigin = new StackFrame(v);}}, toString: function () {var fileName = this.getFileName() || "",lineNumber = this.getLineNumber() || "",columnNumber = this.getColumnNumber() || "",functionName = this.getFunctionName() || "";return this.getIsEval() ? fileName ? "[eval] (" + fileName + ":" + lineNumber + ":" + columnNumber + ")" : "[eval]:" + lineNumber + ":" + columnNumber : functionName ? functionName + " (" + fileName + ":" + lineNumber + ":" + columnNumber + ")" : fileName + ":" + lineNumber + ":" + columnNumber;} }, StackFrame.fromString = function (str) {var argsStartIndex = str.indexOf("("),argsEndIndex = str.lastIndexOf(")"),functionName = str.substring(0, argsStartIndex),args = str.substring(argsStartIndex + 1, argsEndIndex).split(","),locationString = str.substring(argsEndIndex + 1);if (0 === locationString.indexOf("@")) var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, ""),fileName = parts[1],lineNumber = parts[2],columnNumber = parts[3];return new StackFrame({ functionName: functionName, args: args || void 0, fileName: fileName, lineNumber: lineNumber || void 0, columnNumber: columnNumber || void 0 });};for (var i = 0; i < booleanProps.length; i++) StackFrame.prototype["get" + _capitalize(booleanProps[i])] = _getter(booleanProps[i]), StackFrame.prototype["set" + _capitalize(booleanProps[i])] = function (p) {return function (v) {this[p] = Boolean(v);};}(booleanProps[i]);for (var j = 0; j < numericProps.length; j++) StackFrame.prototype["get" + _capitalize(numericProps[j])] = _getter(numericProps[j]), StackFrame.prototype["set" + _capitalize(numericProps[j])] = function (p) {return function (v) {if (!_isNumber(v)) throw new TypeError(p + " must be a Number");this[p] = Number(v);};}(numericProps[j]);for (var k = 0; k < stringProps.length; k++) StackFrame.prototype["get" + _capitalize(stringProps[k])] = _getter(stringProps[k]), StackFrame.prototype["set" + _capitalize(stringProps[k])] = function (p) {return function (v) {this[p] = String(v);};}(stringProps[k]);return StackFrame;}();var ErrorStackParser = (StackFrame = stackframe.exports, FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/, CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m, SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/, { parse: function (error) {if (void 0 !== error.stacktrace || void 0 !== error["opera#sourceloc"]) return this.parseOpera(error);if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) return this.parseV8OrIE(error);if (error.stack) return this.parseFFOrSafari(error);throw new Error("Cannot parse given Error object");}, extractLocation: function (urlLike) {if (-1 === urlLike.indexOf(":")) return [urlLike];var parts = /(.+?)(?::(\d+))?(?::(\d+))?$/.exec(urlLike.replace(/[()]/g, ""));return [parts[1], parts[2] || void 0, parts[3] || void 0];}, parseV8OrIE: function (error) {return error.stack.split("\n").filter(function (line) {return !!line.match(CHROME_IE_STACK_REGEXP);}, this).map(function (line) {line.indexOf("(eval ") > -1 && (line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, ""));var sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, ""),location = sanitizedLine.match(/ (\(.+\)$)/);sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;var locationParts = this.extractLocation(location ? location[1] : sanitizedLine),functionName = location && sanitizedLine || void 0,fileName = ["eval", "<anonymous>"].indexOf(locationParts[0]) > -1 ? void 0 : locationParts[0];return new StackFrame({ functionName: functionName, fileName: fileName, lineNumber: locationParts[1], columnNumber: locationParts[2], source: line });}, this);}, parseFFOrSafari: function (error) {return error.stack.split("\n").filter(function (line) {return !line.match(SAFARI_NATIVE_CODE_REGEXP);}, this).map(function (line) {if (line.indexOf(" > eval") > -1 && (line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1")), -1 === line.indexOf("@") && -1 === line.indexOf(":")) return new StackFrame({ functionName: line });var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/,matches = line.match(functionNameRegex),functionName = matches && matches[1] ? matches[1] : void 0,locationParts = this.extractLocation(line.replace(functionNameRegex, ""));return new StackFrame({ functionName: functionName, fileName: locationParts[0], lineNumber: locationParts[1], columnNumber: locationParts[2], source: line });}, this);}, parseOpera: function (e) {return !e.stacktrace || e.message.indexOf("\n") > -1 && e.message.split("\n").length > e.stacktrace.split("\n").length ? this.parseOpera9(e) : e.stack ? this.parseOpera11(e) : this.parseOpera10(e);}, parseOpera9: function (e) {for (var lineRE = /Line (\d+).*script (?:in )?(\S+)/i, lines = e.message.split("\n"), result = [], i = 2, len = lines.length; i < len; i += 2) {var match = lineRE.exec(lines[i]);match && result.push(new StackFrame({ fileName: match[2], lineNumber: match[1], source: lines[i] }));}return result;}, parseOpera10: function (e) {for (var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i, lines = e.stacktrace.split("\n"), result = [], i = 0, len = lines.length; i < len; i += 2) {var match = lineRE.exec(lines[i]);match && result.push(new StackFrame({ functionName: match[3] || void 0, fileName: match[2], lineNumber: match[1], source: lines[i] }));}return result;}, parseOpera11: function (error) {return error.stack.split("\n").filter(function (line) {return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);}, this).map(function (line) {var argsRaw,tokens = line.split("@"),locationParts = this.extractLocation(tokens.pop()),functionCall = tokens.shift() || "",functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0;functionCall.match(/\(([^)]*)\)/) && (argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, "$1"));var args = void 0 === argsRaw || "[arguments not available]" === argsRaw ? void 0 : argsRaw.split(",");return new StackFrame({ functionName: functionName, args: args, fileName: locationParts[0], lineNumber: locationParts[1], columnNumber: locationParts[2], source: line });}, this);} });const IN_NODE = "undefined" != typeof process && process.release && "node" === process.release.name && void 0 === process.browser;let nodeUrlMod, nodeFetch, nodePath, nodeVmMod, nodeFsPromisesMod, resolvePath, pathSep, loadBinaryFile, loadScript;if (resolvePath = IN_NODE ? function (path, base) {return nodePath.resolve(base || ".", path);} : function (path, base) {return void 0 === base && (base = location), new URL(path, base).toString();}, IN_NODE || (pathSep = "/"), loadBinaryFile = IN_NODE ? async function (path, _file_sub_resource_hash) {if (path.startsWith("file://") && (path = path.slice("file://".length)), path.includes("://")) {let response = await nodeFetch(path);if (!response.ok) throw new Error(`Failed to load '${path}': request failed.`);return new Uint8Array(await response.arrayBuffer());}{const data = await nodeFsPromisesMod.readFile(path);return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);}} : async function (path, subResourceHash) {const url = new URL(path, location);let options = subResourceHash ? { integrity: subResourceHash } : {},response = await fetch(url, options);if (!response.ok) throw new Error(`Failed to load '${url}': request failed.`);return new Uint8Array(await response.arrayBuffer());}, globalThis.document) loadScript = async (url) => await import( /* webpackIgnore: true */url);else if (globalThis.importScripts) loadScript = async (url) => {try {globalThis.importScripts(url);} catch (e) {if (!(e instanceof TypeError)) throw e;await import( /* webpackIgnore: true */url);}};else {if (!IN_NODE) throw new Error("Cannot determine runtime environment");loadScript = async function (url) {url.startsWith("file://") && (url = url.slice("file://".length));url.includes("://") ? nodeVmMod.runInThisContext(await (await nodeFetch(url)).text()) : await import( /* webpackIgnore: true */nodeUrlMod.pathToFileURL(url).href);};}function __values(o) {var s = "function" == typeof Symbol && Symbol.iterator,m = s && o[s],i = 0;if (m) return m.call(o);if (o && "number" == typeof o.length) return { next: function () {return o && i >= o.length && (o = void 0), { value: o && o[i++], done: !o };} };throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");}function __asyncValues(o) {if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");var i,m = o[Symbol.asyncIterator];return m ? m.call(o) : (o = __values(o), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {return this;}, i);function verb(n) {i[n] = o[n] && function (v) {return new Promise(function (resolve, reject) {(function (resolve, reject, d, v) {Promise.resolve(v).then(function (v) {resolve({ value: v, done: d });}, reject);})(resolve, reject, (v = o[n](v)).done, v.value);});};}}const getFsHandles = async (dirHandle) => {const handles = [];await async function collect(curDirHandle) {var e_1, _a;try {for (var _c, _b = __asyncValues(curDirHandle.values()); !(_c = await _b.next()).done;) {const entry = _c.value;handles.push(entry), "directory" === entry.kind && (await collect(entry));}} catch (e_1_1) {e_1 = { error: e_1_1 };} finally {try {_c && !_c.done && (_a = _b.return) && (await _a.call(_b));} finally {if (e_1) throw e_1.error;}}}(dirHandle);const result = new Map();result.set(".", dirHandle);for (const handle of handles) {const relativePath = (await dirHandle.resolve(handle)).join("/");result.set(relativePath, handle);}return result;};function finalizeBootstrap(API, config) {API.runPythonInternal_dict = API._pyodide._base.eval_code("{}"), API.importlib = API.runPythonInternal("import importlib; importlib");let import_module = API.importlib.import_module;API.sys = import_module("sys"), API.sys.path.insert(0, config.homedir), API.os = import_module("os");let globals = API.runPythonInternal("import __main__; __main__.__dict__"),builtins = API.runPythonInternal("import builtins; builtins.__dict__");var builtins_dict;API.globals = (builtins_dict = builtins, new Proxy(globals, { get: (target, symbol) => "get" === symbol ? (key) => {let result = target.get(key);return void 0 === result && (result = builtins_dict.get(key)), result;} : "has" === symbol ? (key) => target.has(key) || builtins_dict.has(key) : Reflect.get(target, symbol) }));let importhook = API._pyodide._importhook;importhook.register_js_finder(), importhook.register_js_module("js", config.jsglobals);let pyodide = API.makePublicAPI();return importhook.register_js_module("pyodide_js", pyodide), API.pyodide_py = import_module("pyodide"), API.pyodide_code = import_module("pyodide.code"), API.pyodide_ffi = import_module("pyodide.ffi"), API.package_loader = import_module("pyodide._package_loader"), API.sitepackages = API.package_loader.SITE_PACKAGES.__str__(), API.dsodir = API.package_loader.DSO_DIR.__str__(), API.defaultLdLibraryPath = [API.dsodir, API.sitepackages], API.os.environ.__setitem__("LD_LIBRARY_PATH", API.defaultLdLibraryPath.join(":")), pyodide.pyodide_py = API.pyodide_py, pyodide.globals = API.globals, pyodide;}async function loadPyodide(options = {}) {await async function () {if (!IN_NODE) return;if (nodeUrlMod = (await import('url')).default, nodeFsPromisesMod = await import('fs/promises'), nodeFetch = globalThis.fetch ? fetch : (await import('node-fetch')).default, nodeVmMod = (await import('vm')).default, nodePath = await import('path'), pathSep = nodePath.sep, "undefined" != typeof require) return;const node_modules = { fs: await import('fs'), crypto: await import('crypto'), ws: await import('ws'), child_process: await import('child_process') };globalThis.require = function (mod) {return node_modules[mod];};}();let indexURL = options.indexURL || function () {if ("string" == typeof __dirname) return __dirname;let err;try {throw new Error();} catch (e) {err = e;}let fileName = ErrorStackParser.parse(err)[0].fileName;const indexOfLastSlash = fileName.lastIndexOf(pathSep);if (-1 === indexOfLastSlash) throw new Error("Could not extract indexURL path from pyodide module location");return fileName.slice(0, indexOfLastSlash);}();indexURL = resolvePath(indexURL), indexURL.endsWith("/") || (indexURL += "/"), options.indexURL = indexURL;const default_config = { fullStdLib: !1, jsglobals: globalThis, stdin: globalThis.prompt ? globalThis.prompt : void 0, homedir: "/home/pyodide", lockFileURL: indexURL + "repodata.json", args: [], _node_mounts: [] },config = Object.assign(default_config, options),pyodide_py_tar_promise = loadBinaryFile(config.indexURL + "pyodide_py.tar"),Module = function () {let Module = { noImageDecoding: !0, noAudioDecoding: !0, noWasmDecoding: !1, preRun: [], quit: (status, toThrow) => {throw Module.exited = { status: status, toThrow: toThrow }, toThrow;} };return Module;}();Module.print = config.stdout, Module.printErr = config.stderr, Module.preRun.push(() => {for (const mount of config._node_mounts) Module.FS.mkdirTree(mount), Module.FS.mount(Module.NODEFS, { root: mount }, mount);}), Module.arguments = config.args;const API = { config: config };Module.API = API, function (Module, path) {Module.preRun.push(function () {try {Module.FS.mkdirTree(path);} catch (e) {console.error(`Error occurred while making a home directory '${path}':`), console.error(e), console.error("Using '/' for a home directory instead"), path = "/";}Module.ENV.HOME = path, Module.FS.chdir(path);});}(Module, config.homedir);const moduleLoaded = new Promise((r) => Module.postRun = r);if (Module.locateFile = (path) => config.indexURL + path, "function" != typeof _createPyodideModule) {const scriptSrc = `${config.indexURL}pyodide.asm.js`;await loadScript(scriptSrc);}if (await _createPyodideModule(Module), await moduleLoaded, Module.exited) throw Module.exited.toThrow;if ("0.22.1" !== API.version) throw new Error(`Pyodide version does not match: '0.22.1' <==> '${API.version}'. If you updated the Pyodide version, make sure you also updated the 'indexURL' parameter passed to loadPyodide.`);Module.locateFile = (path) => {throw new Error("Didn't expect to load any more file_packager files!");}, function (module) {const FS = module.FS,MEMFS = module.FS.filesystems.MEMFS,PATH = module.PATH,nativeFSAsync = { DIR_MODE: 16895, FILE_MODE: 33279, mount: function (mount) {if (!mount.opts.fileSystemHandle) throw new Error("opts.fileSystemHandle is required");return MEMFS.mount.apply(null, arguments);}, syncfs: async (mount, populate, callback) => {try {const local = nativeFSAsync.getLocalSet(mount),remote = await nativeFSAsync.getRemoteSet(mount),src = populate ? remote : local,dst = populate ? local : remote;await nativeFSAsync.reconcile(mount, src, dst), callback(null);} catch (e) {callback(e);}}, getLocalSet: (mount) => {let entries = Object.create(null);function isRealDir(p) {return "." !== p && ".." !== p;}function toAbsolute(root) {return (p) => PATH.join2(root, p);}let check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));for (; check.length;) {let path = check.pop(),stat = FS.stat(path);FS.isDir(stat.mode) && check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path))), entries[path] = { timestamp: stat.mtime, mode: stat.mode };}return { type: "local", entries: entries };}, getRemoteSet: async (mount) => {const entries = Object.create(null),handles = await getFsHandles(mount.opts.fileSystemHandle);for (const [path, handle] of handles) "." !== path && (entries[PATH.join2(mount.mountpoint, path)] = { timestamp: "file" === handle.kind ? (await handle.getFile()).lastModifiedDate : new Date(), mode: "file" === handle.kind ? nativeFSAsync.FILE_MODE : nativeFSAsync.DIR_MODE });return { type: "remote", entries: entries, handles: handles };}, loadLocalEntry: (path) => {const node = FS.lookupPath(path).node,stat = FS.stat(path);if (FS.isDir(stat.mode)) return { timestamp: stat.mtime, mode: stat.mode };if (FS.isFile(stat.mode)) return node.contents = MEMFS.getFileDataAsTypedArray(node), { timestamp: stat.mtime, mode: stat.mode, contents: node.contents };throw new Error("node type not supported");}, storeLocalEntry: (path, entry) => {if (FS.isDir(entry.mode)) FS.mkdirTree(path, entry.mode);else {if (!FS.isFile(entry.mode)) throw new Error("node type not supported");FS.writeFile(path, entry.contents, { canOwn: !0 });}FS.chmod(path, entry.mode), FS.utime(path, entry.timestamp, entry.timestamp);}, removeLocalEntry: (path) => {var stat = FS.stat(path);FS.isDir(stat.mode) ? FS.rmdir(path) : FS.isFile(stat.mode) && FS.unlink(path);}, loadRemoteEntry: async (handle) => {if ("file" === handle.kind) {const file = await handle.getFile();return { contents: new Uint8Array(await file.arrayBuffer()), mode: nativeFSAsync.FILE_MODE, timestamp: file.lastModifiedDate };}if ("directory" === handle.kind) return { mode: nativeFSAsync.DIR_MODE, timestamp: new Date() };throw new Error("unknown kind: " + handle.kind);}, storeRemoteEntry: async (handles, path, entry) => {const parentDirHandle = handles.get(PATH.dirname(path)),handle = FS.isFile(entry.mode) ? await parentDirHandle.getFileHandle(PATH.basename(path), { create: !0 }) : await parentDirHandle.getDirectoryHandle(PATH.basename(path), { create: !0 });if ("file" === handle.kind) {const writable = await handle.createWritable();await writable.write(entry.contents), await writable.close();}handles.set(path, handle);}, removeRemoteEntry: async (handles, path) => {const parentDirHandle = handles.get(PATH.dirname(path));await parentDirHandle.removeEntry(PATH.basename(path)), handles.delete(path);}, reconcile: async (mount, src, dst) => {let total = 0;const create = [];Object.keys(src.entries).forEach(function (key) {const e = src.entries[key],e2 = dst.entries[key];(!e2 || FS.isFile(e.mode) && e.timestamp.getTime() > e2.timestamp.getTime()) && (create.push(key), total++);}), create.sort();const remove = [];if (Object.keys(dst.entries).forEach(function (key) {src.entries[key] || (remove.push(key), total++);}), remove.sort().reverse(), !total) return;const handles = "remote" === src.type ? src.handles : dst.handles;for (const path of create) {const relPath = PATH.normalize(path.replace(mount.mountpoint, "/")).substring(1);if ("local" === dst.type) {const handle = handles.get(relPath),entry = await nativeFSAsync.loadRemoteEntry(handle);nativeFSAsync.storeLocalEntry(path, entry);} else {const entry = nativeFSAsync.loadLocalEntry(path);await nativeFSAsync.storeRemoteEntry(handles, relPath, entry);}}for (const path of remove) if ("local" === dst.type) nativeFSAsync.removeLocalEntry(path);else {const relPath = PATH.normalize(path.replace(mount.mountpoint, "/")).substring(1);await nativeFSAsync.removeRemoteEntry(handles, relPath);}} };module.FS.filesystems.NATIVEFS_ASYNC = nativeFSAsync;}(Module);const pyodide_py_tar = await pyodide_py_tar_promise;!function (Module, pyodide_py_tar) {let stream = Module.FS.open("/pyodide_py.tar", "w");Module.FS.write(stream, pyodide_py_tar, 0, pyodide_py_tar.byteLength, void 0, !0), Module.FS.close(stream);let [errcode, captured_stderr] = Module.API.rawRun('\nfrom sys import version_info\npyversion = f"python{version_info.major}.{version_info.minor}"\nimport shutil\nshutil.unpack_archive("/pyodide_py.tar", f"/lib/{pyversion}/")\ndel shutil\nimport importlib\nimportlib.invalidate_caches()\ndel importlib\n');errcode && Module.API.fatal_loading_error("Failed to unpack standard library.\n", captured_stderr), Module.FS.unlink("/pyodide_py.tar");}(Module, pyodide_py_tar);let [err, captured_stderr] = API.rawRun("import _pyodide_core");err && Module.API.fatal_loading_error("Failed to import _pyodide_core\n", captured_stderr);const pyodide = finalizeBootstrap(API, config);if (pyodide.version.includes("dev") || API.setCdnUrl(`https://cdn.jsdelivr.net/pyodide/v${pyodide.version}/full/`), await API.packageIndexReady, API._pyodide._importhook.register_module_not_found_hook(API._import_name_to_package_name), "0.22.1" !== API.repodata_info.version) throw new Error("Lock file version doesn't match Pyodide version");return API.package_loader.init_loaded_packages(), config.fullStdLib && (await pyodide.loadPackage(API._pyodide._importhook.UNVENDORED_STDLIBS)), API.initializeStreams(config.stdin, config.stdout, config.stderr), pyodide;}

globalThis.webPy = await loadPyodide({
	indexURL: "https://cdn.jsdelivr.net/pyodide/v0.22.1/full/",
	fullStdLib: true,
});

let webPy$1 = globalThis.webPy;

await webPy$1.loadPackage([ "micropip" ]);

const micropip = webPy$1.pyimport("micropip");

/**
 * @module main
 */

let message = document.getElementById("status");
message.text = "WebR Loadingâ€¦";

// LOAD PYTHON!

message.text = "Pyodide Loadingâ€¦";

// get some info from python. This `runPython` is kind of nice to work with tbh.
const res = await webPy$1.runPython(`
import sys
import json
json.dumps({ 'version': sys.version, 'executable': sys.executable, 'platform': sys.platform }, indent=2)
`);

// display stuffs!
const pyOut = document.getElementById("py-output");
pyOut.innerText = res;

const rOut = document.getElementById("r-output"); 
rOut.innerText = await webR.evalRString("R.version.string");

// I highly suggest opening up DevTools and reloading the page to watch this
message.text = "Installing matplotlib";

await micropip.install(["matplotlib", "numpy"]);

// I need to do some penance for this violation of sanity.
const plt = await webPy.runPython(`
import matplotlib.pyplot as plt
import io, base64
import numpy as np

y = [0.22, 0.34, 0.5, 0.56, 0.78]
x = [0.17, 0.5, 0.855]
X, Y = np.meshgrid(x, y)

fig, ax = plt.subplots(figsize=(6, 4), dpi=100)
ax.set(xlim=(0, 1), ylim=(0, 1), xticks=[], yticks=[])
ax.spines[:].set_visible(False)
ax.text(0.5, 0.5, 'plot', fontsize=128, ha='center', va='center', zorder=1)
ax.hlines(y, x[0], x[-1], color='grey')
ax.vlines(x, y[0], y[-1], color='grey')
ax.plot(X.ravel(), Y.ravel(), 'o')
pad_x = 0.02
pad_y = 0.04
ax.text(x[0] - pad_x, y[0], 'bottom', ha='right', va='center')
ax.text(x[0] - pad_x, y[1], 'baseline', ha='right', va='center')
ax.text(x[0] - pad_x, y[2], 'center', ha='right', va='center')
ax.text(x[0] - pad_x, y[3], 'center_baseline', ha='right', va='center')
ax.text(x[0] - pad_x, y[4], 'top', ha='right', va='center')
ax.text(x[0], y[0] - pad_y, 'left', ha='center', va='top')
ax.text(x[1], y[0] - pad_y, 'center', ha='center', va='top')
ax.text(x[2], y[0] - pad_y, 'right', ha='center', va='top')
ax.set_xlabel('horizontalalignment', fontsize=14)
ax.set_ylabel('verticalalignment', fontsize=14, labelpad=35)
ax.set_title('Relative position of text anchor point depending on alignment')

buf = io.BytesIO()
fig.savefig(buf, format='png')
buf.seek(0)
'data:image/png;base64,' + base64.b64encode(buf.read()).decode('UTF-8')
`);

// we get to put that base64 encoded img right into our placeholder!
const pltOut = document.getElementById("py-plt-output"); 
pltOut.src = plt;

message.text = "Ready";
